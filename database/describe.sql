----
create table public.playback_events (
  id uuid not null default gen_random_uuid (),
  episodeid text not null,
  podcastid text not null,
  userid uuid null,
  client text null,
  ip inet null,
  playedat timestamp with time zone not null default now(),
  constraint playback_events_pkey primary key (id)
) TABLESPACE pg_default;

----
create table public.shows (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone null default now(),
  title text not null,
  show_date text not null,
  hosts text[] null,
  description text[] null,
  mp3_url text not null,
  duration integer null,
  rss_url text null,
  program_id bigint null,
  program_image text null,
  constraint shows_pkey primary key (id)
) TABLESPACE pg_default;

create index IF not exists idx_shows_id_podcastid_publishedat on public.shows using btree (id, program_id, created_at) TABLESPACE pg_default;

create index IF not exists shows_program_id_idx on public.shows using btree (program_id) TABLESPACE pg_default;

create index IF not exists shows_created_at_idx on public.shows using btree (created_at) TABLESPACE pg_default;

create index IF not exists shows_show_date_text_idx on public.shows using btree (show_date) TABLESPACE pg_default;

create index IF not exists shows_podcast_id_idx on public.shows using btree (COALESCE(program_id, id)) TABLESPACE pg_default;

create index IF not exists shows_created_at_desc_idx on public.shows using btree (created_at desc) TABLESPACE pg_default;

create index IF not exists shows_program_id_id_desc on public.shows using btree (program_id, id desc) TABLESPACE pg_default;

create index IF not exists shows_id_desc on public.shows using btree (id desc) TABLESPACE pg_default;

----


create view public.episodes as
select
  id,
  case
    when program_id is null then id
    else program_id
  end as "podcastId",
  title,
  COALESCE(description[1], ''::text) as description,
  mp3_url as "audioUrl",
  created_at as "publishedAt",
  show_date as "showDate",
  COALESCE(duration * 60, 0) as duration,
  program_image as "imageUrl",
  COALESCE(hosts, '{}'::text[]) as hosts
from
  shows s
order by
  id desc;
  
  
----



create view public.podcasts as
with
  base as (
    select
      COALESCE(shows.program_id::text, shows.id::text) as podcast_id,
      shows.id as episode_id,
      shows.created_at,
      shows.title as episode_title,
      shows.show_date,
      shows.hosts,
      shows.description,
      shows.mp3_url,
      shows.duration,
      shows.program_image
    from
      shows
  )
select
  p.podcast_id as id,
  COALESCE(lat.episode_title, 'Ismeretlen m≈±sor'::text) as title,
  COALESCE(p.podcast_description, ''::text) as description,
  p.cover_image_url,
  p.episode_count,
  COALESCE(lat.hosts, array[]::text[]) as hosts,
  jsonb_build_object(
    'id',
    lat.episode_id,
    'title',
    lat.episode_title,
    'show_date',
    lat.show_date,
    'mp3_url',
    lat.mp3_url,
    'duration',
    lat.duration,
    'hosts',
    COALESCE(lat.hosts, array[]::text[])
  ) as latest_episode,
  p.last_updated
from
  (
    select
      b.podcast_id,
      max(b.program_image) as cover_image_url,
      count(*) as episode_count,
      max(b.created_at) as last_updated,
      (
        select
          COALESCE(bb.description[1], ''::text) as "coalesce"
        from
          base bb
        where
          bb.podcast_id = b.podcast_id
          and bb.description is not null
        limit
          1
      ) as podcast_description
    from
      base b
    group by
      b.podcast_id
  ) p
  left join lateral (
    select
      b.podcast_id,
      b.episode_id,
      b.episode_title,
      b.show_date,
      b.description,
      b.mp3_url,
      b.duration,
      b.hosts,
      b.created_at
    from
      base b
    where
      b.podcast_id = p.podcast_id
    order by
      (
        case
          when NULLIF(b.show_date, ''::text) is null then 1
          else 0
        end
      ),
      (NULLIF(b.show_date, ''::text)) desc,
      b.created_at desc
    limit
      1
  ) lat on true;
  
  
----


create view public.top_shows_this_year as
select
  program_id as id,
  title,
  count(program_id) as count
from
  shows
where
  EXTRACT(
    year
    from
      (created_at AT TIME ZONE 'UTC'::text)
  ) = EXTRACT(
    year
    from
      (now() AT TIME ZONE 'UTC'::text)
  )
group by
  program_id,
  title
order by
  (count(program_id)) desc
limit
  8;